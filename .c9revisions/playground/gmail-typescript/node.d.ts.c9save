{"ts":1349349403998,"silentsave":true,"restoring":false,"patch":[[]],"length":0}
{"contributors":[],"silentsave":false,"ts":1349349476325,"patch":[[{"diffs":[[1,"/************************************************\r\n*                                               *\r\n*               Node.js v0.8.8 API              *\r\n*                                               *\r\n************************************************/\r\n\r\n/************************************************\r\n*                                               *\r\n*                   GLOBAL                      *\r\n*                                               *\r\n************************************************/\r\ndeclare var process: NodeProcess;\r\ndeclare var global: any;\r\n\r\ndeclare var console: {\r\n   log(...data: any[]): void;\r\n   info(...data: any[]): void;\r\n   error(...data: any[]): void;\r\n   warn(...data: any[]): void;\r\n   dir(obj: any): void;\r\n   timeEnd(label: string): void;\r\n   trace(label: string): void;\r\n   assert(expression: any, ...message: string[]): void;\r\n}\r\n\r\ndeclare var __filename: string;\r\ndeclare var __dirname: string;\r\n\r\ndeclare function setTimeout(callback: () => void , ms: number): any;\r\ndeclare function clearTimeout(timeoutId: any);\r\ndeclare function setInterval(callback: () => void , ms: number): any;\r\ndeclare function clearInterval(intervalId: any);\r\n\r\ndeclare var require: {\r\n   (id: string): any;\r\n   resolve(): string;\r\n   cache: any;\r\n   extensions: any;\r\n}\r\n\r\ndeclare var module: {\r\n   exports: any;\r\n   require(id: string): any;\r\n   id: string;\r\n   filename: string;\r\n   loaded: bool;\r\n   parent: any;\r\n   children: any[];\r\n}\r\n\r\n// Same as module.exports\r\ndeclare var exports: any;\r\ndeclare var SlowBuffer: {\r\n   new (str: string, encoding?: string): NodeBuffer;\r\n   new (size: number): NodeBuffer;\r\n   new (array: any[]): NodeBuffer;\r\n   prototype: NodeBuffer;\r\n   isBuffer(obj: any): bool;\r\n   byteLength(string: string, encoding?: string): number;\r\n   concat(list: NodeBuffer[], totalLength?: number): NodeBuffer;\r\n};\r\ndeclare var Buffer: {\r\n   new (str: string, encoding?: string): NodeBuffer;\r\n   new (size: number): NodeBuffer;\r\n   new (array: any[]): NodeBuffer;\r\n   prototype: NodeBuffer;\r\n   isBuffer(obj: any): bool;\r\n   byteLength(string: string, encoding?: string): number;\r\n   concat(list: NodeBuffer[], totalLength?: number): NodeBuffer;\r\n}\r\n\r\n/************************************************\r\n*                                               *\r\n*                   INTERFACES                  *\r\n*                                               *\r\n************************************************/\r\n\r\ninterface EventEmitter {\r\n   addListener(event: string, listener: Function);\r\n   on(event: string, listener: Function);\r\n   once(event: string, listener: Function): void;\r\n   removeListener(event: string, listener: Function): void;\r\n   removeAllListener(event: string): void;\r\n   setMaxListeners(n: number): void;\r\n   listeners(event: string): { Function; }[];\r\n   emit(event: string, arg1?: any, arg2?: any): void;\r\n}\r\n\r\ninterface WritableStream extends EventEmitter {\r\n   writable: bool;\r\n   write(str: string, encoding?: string, fd?: string): bool;\r\n   write(buffer: NodeBuffer): bool;\r\n   end(): void;\r\n   end(str: string, enconding: string): void;\r\n   end(buffer: NodeBuffer): void;\r\n   destroy(): void;\r\n   destroySoon(): void;\r\n}\r\n\r\ninterface ReadableStream extends EventEmitter {\r\n   readable: bool;\r\n   setEncoding(encoding: string): void;\r\n   pause(): void;\r\n   resume(): void;\r\n   destroy(): void;\r\n   pipe(destination: WritableStream, options?: { end?: bool; }): void;\r\n}\r\n\r\ninterface NodeProcess extends EventEmitter {\r\n   stdout: WritableStream;\r\n   stderr: WritableStream;\r\n   stdin: ReadableStream;\r\n   argv: string[];\r\n   execPath: string;\r\n   abort(): void;\r\n   chdir(directory: string): void;\r\n   cwd(): void;\r\n   env: any;\r\n   exit(code?: number): void;\r\n   getgid(): number;\r\n   setgid(id: number): void;\r\n   getuid(): number;\r\n   setuid(id: number): void;\r\n   version: string;\r\n   versions: { http_parser: string; node: string; v8: string; ares: string; uv: string; zlib: string; openssl: string; };\r\n   config: {\r\n       target_defaults: {\r\n           cflags: any[];\r\n           default_configuration: string;\r\n           defines: string[];\r\n           include_dirs: string[];\r\n           libraries: string[];\r\n       };\r\n       variables: {\r\n       clang: number;\r\n       host_arch: string;\r\n       node_install_npm: bool;\r\n       node_install_waf: bool;\r\n       node_prefix: string;\r\n       node_shared_openssl: bool;\r\n       node_shared_v8: bool;\r\n       node_shared_zlib: bool;\r\n       node_use_dtrace: bool;\r\n       node_use_etw: bool;\r\n       node_use_openssl: bool;\r\n       target_arch: string;\r\n       v8_no_strict_aliasing: number;\r\n       v8_use_snapshot: bool;\r\n       visibility: string;\r\n   };\r\n   };\r\n   kill(pid: number, signal?: string): void;\r\n   pid: number;\r\n   title: string;\r\n   arch: string;\r\n   platform: string;\r\n   memoryUsage(): { rss: number; heapTotal; number; heapUsed: number; };\r\n   nextTick(callback: Function): void;\r\n   umask(mask?: number): number;\r\n   uptime(): number;\r\n   hrtime(): number[];\r\n}\r\n\r\n// Buffer class\r\ninterface NodeBuffer {\r\n   [index: number]: number;\r\n   write(string: string, offset?: number, length?: number, encoding?: string): number;\r\n   toString(encoding: string, start: number, end: number): string;\r\n   length: number;\r\n   copy(targetBuffer: NodeBuffer, targetStart?: number, sourceStart?: number, sourceEnd?: number): void;\r\n   slice(start?: number, end?: number): NodeBuffer;\r\n   readUInt8(offset: number, noAsset?: bool): number;\r\n   readUInt16LE(offset: number, noAssert?: bool): number;\r\n   readUInt16BE(offset: number, noAssert?: bool): number;\r\n   readUInt32LE(offset: number, noAssert?: bool): number;\r\n   readUInt32BE(offset: number, noAssert?: bool): number;\r\n   readInt8(offset: number, noAssert?: bool): number;\r\n   readInt16LE(offset: number, noAssert?: bool): number;\r\n   readInt16BE(offset: number, noAssert?: bool): number;\r\n   readInt32LE(offset: number, noAssert?: bool): number;\r\n   readInt32BE(offset: number, noAssert?: bool): number;\r\n   readFloatLE(offset: number, noAssert?: bool): number;\r\n   readFloatBE(offset: number, noAssert?: bool): number;\r\n   readDoubleLE(offset: number, noAssert?: bool): number;\r\n   readDoubleBE(offset: number, noAssert?: bool): number;\r\n   writeUInt8(value: number, offset: number, noAssert?: bool): void;\r\n   writeUInt16LE(value: number, offset: number, noAssert?: bool): void;\r\n   writeUInt16BE(value: number, offset: number, noAssert?: bool): void;\r\n   writeUInt32LE(value: number, offset: number, noAssert?: bool): void;\r\n   writeUInt32BE(value: number, offset: number, noAssert?: bool): void;\r\n   writeInt8(value: number, offset: number, noAssert?: bool): void;\r\n   writeInt16LE(value: number, offset: number, noAssert?: bool): void;\r\n   writeInt16BE(value: number, offset: number, noAssert?: bool): void;\r\n   writeInt32LE(value: number, offset: number, noAssert?: bool): void;\r\n   writeInt32BE(value: number, offset: number, noAssert?: bool): void;\r\n   writeFloatLE(value: number, offset: number, noAssert?: bool): void;\r\n   writeFloatBE(value: number, offset: number, noAssert?: bool): void;\r\n   writeDoubleLE(value: number, offset: number, noAssert?: bool): void;\r\n   writeDoubleBE(value: number, offset: number, noAssert?: bool): void;\r\n   fill(value: any, offset?: number, end?: number): void;\r\n   INSPECT_MAX_BYTES: number;\r\n}\r\n\r\n/************************************************\r\n*                                               *\r\n*                   MODULES                     *\r\n*                                               *\r\n************************************************/\r\ndeclare module \"querystring\" {\r\n   export function stringify(obj: any, sep?: string, eq?: string): string;\r\n   export function parse(str: string, sep?: string, eq?: string, options?: { maxKeys?: number; }): any;\r\n   export function escape(): any;\r\n   export function unescape(): any;\r\n}\r\n\r\ndeclare module \"events\" {\r\n   export interface NodeEventEmitter {\r\n       addListener(event: string, listener: Function);\r\n       on(event: string, listener: Function): any;\r\n       once(event: string, listener: Function): void;\r\n       removeListener(event: string, listener: Function): void;\r\n       removeAllListener(event: string): void;\r\n       setMaxListeners(n: number): void;\r\n       listeners(event: string): { Function; }[];\r\n       emit(event: string, arg1?: any, arg2?: any): void;\r\n   }\r\n\r\n   export var EventEmitter: NodeEventEmitter;\r\n}\r\n\r\ndeclare module \"http\" {\r\n   import events = module(\"events\");\r\n   import net = module(\"net\");\r\n   import stream = module(\"stream\");\r\n\r\n   export interface Server extends events.NodeEventEmitter {\r\n       listen(port: number, hostname?: string, backlog?: number, callback?: Function): void;\r\n       listen(path: string, callback?: Function): void;\r\n       listen(handle: any, listeningListener?: Function): void;\r\n       close(cb?: any): void;\r\n       maxHeadersCount: number;\r\n   }\r\n   export interface ServerRequest extends events.NodeEventEmitter, stream.ReadableStream {\r\n       method: string;\r\n       url: string;\r\n       headers: string;\r\n       trailers: string;\r\n       httpVersion: string;\r\n       setEncoding(encoding?: string): void;\r\n       pause(): void;\r\n       resume(): void;\r\n       connection: net.NodeSocket;\r\n   }\r\n   export interface ServerResponse extends events.NodeEventEmitter, stream.WritableStream {\r\n       // Extended base methods\r\n       write(str: string, encoding?: string, fd?: string): bool;\r\n       write(buffer: NodeBuffer): bool;\r\n\r\n       writeContinue(): void;\r\n       writeHead(statusCode: number, reasonPhrase?: string, headers?: any): void;\r\n       writeHead(statusCode: number, headers?: any): void;\r\n       statusCode: number;\r\n       setHeader(name: string, value: string): void;\r\n       sendDate: bool;\r\n       getHeader(name: string): string;\r\n       removeHeader(name: string): void;\r\n       write(chunk: any, encoding?: string): any;\r\n       addTrailers(headers: any): void;\r\n       end(data?: any, encoding?: string): void;\r\n   }\r\n   export interface ClientRequest extends events.NodeEventEmitter, stream.WritableStream {\r\n       // Extended base methods\r\n       write(str: string, encoding?: string, fd?: string): bool;\r\n       write(buffer: NodeBuffer): bool;\r\n\r\n       write(chunk: any, encoding?: string): void;\r\n       end(data?: any, encoding?: string): void;\r\n       abort(): void;\r\n       setTimeout(timeout: number, callback?: Function): void;\r\n       setNoDelay(noDelay?: Function): void;\r\n       setSocketKeepAlive(enable?: bool, initialDelay?: number): void;\r\n   }\r\n   export interface ClientResponse extends events.NodeEventEmitter, stream.ReadableStream {\r\n       statusCode: number;\r\n       httpVersion: string;\r\n       headers: any;\r\n       trailers: any;\r\n       setEncoding(encoding?: string): void;\r\n       pause(): void;\r\n       resume(): void;\r\n   }\r\n   export interface Agent { maxSockets: number; sockets: any; requests: any; }\r\n\r\n   export var STATUS_CODES;\r\n   export function createServer(requestListener?: (request: ServerRequest, response: ServerResponse) =>void ): Server;\r\n   export function createClient(port?: number, host?: string): any;\r\n   export function request(options: any, callback?: Function): ClientRequest;\r\n   export function get(options: any, callback?: Function): ClientRequest;\r\n   export var globalAgent: Agent;\r\n}\r\n\r\ndeclare module \"cluster\" {\r\n   import child_process = module(\"child_process\");\r\n\r\n   export interface ClusterSettings {\r\n       exec: string;\r\n       args: string[];\r\n       silent: bool;\r\n   }\r\n   export interface Worker {\r\n       id: string;\r\n       process: child_process;\r\n       suicide: bool;\r\n       send(message: any, sendHandle?: any): void;\r\n       destroy(): void;\r\n       disconnect(): void;\r\n   }\r\n\r\n\r\n   export var settings: ClusterSettings;\r\n   export var isMaster: bool;\r\n   export var isWorker: bool;\r\n   export function setupMaster(settings?: ClusterSettings): void;\r\n   export function fork(env?: any): Worker;\r\n   export function disconnect(callback?: Function): void;\r\n   export var workers: any;\r\n\r\n   // Event emitter    \r\n   export function addListener(event: string, listener: Function): void;\r\n   export function on(event: string, listener: Function): any;\r\n   export function once(event: string, listener: Function): void;\r\n   export function removeListener(event: string, listener: Function): void;\r\n   export function removeAllListener(event: string): void;\r\n   export function setMaxListeners(n: number): void;\r\n   export function listeners(event: string): { Function; }[];\r\n   export function emit(event: string, arg1?: any, arg2?: any): void;\r\n}\r\n\r\ndeclare module \"zlib\" {\r\n   import stream = module(\"stream\");\r\n   export interface ZlibOptions { chunkSize?: number; windowBits?: number; level?: number; memLevel?: number; strategy?: number; dictionary?: any; }\r\n\r\n   export interface Gzip extends stream.ReadWriteStream { }\r\n   export interface Gunzip extends stream.ReadWriteStream { }\r\n   export interface Deflate extends stream.ReadWriteStream { }\r\n   export interface Inflate extends stream.ReadWriteStream { }\r\n   export interface DeflateRaw extends stream.ReadWriteStream { }\r\n   export interface InflateRaw extends stream.ReadWriteStream { }\r\n   export interface Unzip extends stream.ReadWriteStream { }\r\n\r\n   export function createGzip(options: ZlibOptions): Gzip;\r\n   export function createGunzip(options: ZlibOptions): Gunzip;\r\n   export function createDeflate(options: ZlibOptions): Deflate;\r\n   export function createInflate(options: ZlibOptions): Inflate;\r\n   export function createDeflateRaw(options: ZlibOptions): DeflateRaw;\r\n   export function createInflateRaw(options: ZlibOptions): InflateRaw;\r\n   export function createUnzip(options: ZlibOptions): Unzip;\r\n\r\n   export function deflate(buf: NodeBuffer, callback: (error: Error, result) =>void ): void;\r\n   export function deflateRaw(buf: NodeBuffer, callback: (error: Error, result) =>void ): void;\r\n   export function gzip(buf: NodeBuffer, callback: (error: Error, result) =>void ): void;\r\n   export function gunzip(buf: NodeBuffer, callback: (error: Error, result) =>void ): void;\r\n   export function inflate(buf: NodeBuffer, callback: (error: Error, result) =>void ): void;\r\n   export function inflateRaw(buf: NodeBuffer, callback: (error: Error, result) =>void ): void;\r\n   export function unzip(buf: NodeBuffer, callback: (error: Error, result) =>void ): void;\r\n\r\n   // Constants\r\n   export var Z_NO_FLUSH: number;\r\n   export var Z_PARTIAL_FLUSH: number;\r\n   export var Z_SYNC_FLUSH: number;\r\n   export var Z_FULL_FLUSH: number;\r\n   export var Z_FINISH: number;\r\n   export var Z_BLOCK: number;\r\n   export var Z_TREES: number;\r\n   export var Z_OK: number;\r\n   export var Z_STREAM_END: number;\r\n   export var Z_NEED_DICT: number;\r\n   export var Z_ERRNO: number;\r\n   export var Z_STREAM_ERROR: number;\r\n   export var Z_DATA_ERROR: number;\r\n   export var Z_MEM_ERROR: number;\r\n   export var Z_BUF_ERROR: number;\r\n   export var Z_VERSION_ERROR: number;\r\n   export var Z_NO_COMPRESSION: number;\r\n   export var Z_BEST_SPEED: number;\r\n   export var Z_BEST_COMPRESSION: number;\r\n   export var Z_DEFAULT_COMPRESSION: number;\r\n   export var Z_FILTERED: number;\r\n   export var Z_HUFFMAN_ONLY: number;\r\n   export var Z_RLE: number;\r\n   export var Z_FIXED: number;\r\n   export var Z_DEFAULT_STRATEGY: number;\r\n   export var Z_BINARY: number;\r\n   export var Z_TEXT: number;\r\n   export var Z_ASCII: number;\r\n   export var Z_UNKNOWN: number;\r\n   export var Z_DEFLATED: number;\r\n   export var Z_NULL: number;\r\n}\r\n\r\ndeclare module \"os\" {\r\n   export function tmpDir(): string;\r\n   export function hostname(): string;\r\n   export function type(): string;\r\n   export function platform(): string;\r\n   export function arch(): string;\r\n   export function release(): string;\r\n   export function uptime(): number;\r\n   export function loadavg(): number[];\r\n   export function totalmem(): number;\r\n   export function freemem(): number;\r\n   export function cpus(): { model: string; speed: number; times: { user: number; nice: number; sys: number; idle: number; irq: number; }; }[];\r\n   export function networkInterfaces(): any;\r\n   export var EOL: string;\r\n}\r\n\r\ndeclare module \"https\" {\r\n   import tls = module(\"tls\");\r\n   import events = module(\"events\");\r\n   import http = module(\"http\");\r\n\r\n   export interface ServerOptions {\r\n       pfx?: any;\r\n       key?: any;\r\n       passphrase?: string;\r\n       cert?: any;\r\n       ca?: any;\r\n       crl?: any;\r\n       ciphers?: string;\r\n       honorCipherOrder?: bool;\r\n       requestCert?: bool;\r\n       rejectUnauthorized?: bool;\r\n       NPNProtocols?: any;\r\n       SNICallback?: (servername: string) => any;\r\n   }\r\n\r\n   export interface RequestOptions {\r\n       host?: string;\r\n       hostname?: string;\r\n       port?: number;\r\n       path?: string;\r\n       method?: string;\r\n       headers?: any;\r\n       auth?: string;\r\n       agent?: any;\r\n       pfx?: any;\r\n       key?: any;\r\n       passphrase?: string;\r\n       cert?: any;\r\n       ca?: any;\r\n       ciphers?: string;\r\n       rejectUnauthorized?: bool;\r\n   }\r\n\r\n   export interface NodeAgent {\r\n       maxSockets: number;\r\n       sockets: any;\r\n       requests: any;\r\n   }\r\n   export var Agent: {\r\n       new (options?: RequestOptions): NodeAgent;\r\n   };\r\n   export interface Server extends tls.Server { }\r\n   export function createServer(options: ServerOptions, requestListener?: Function): Server;\r\n   export function request(options: RequestOptions, callback?: (res: events.NodeEventEmitter) =>void ): http.ClientRequest;\r\n   export function get(options: RequestOptions, callback?: (res: events.NodeEventEmitter) =>void ): http.ClientRequest;\r\n   export var globalAgent: NodeAgent;\r\n}\r\n\r\ndeclare module \"punycode\" {\r\n   export function decode(string: string): string;\r\n   export function encode(string: string): string;\r\n   export function toUnicode(domain: string): string;\r\n   export function toASCII(domain: string): string;\r\n   export var ucs2: ucs2;\r\n   interface ucs2 {\r\n       decode(string: string): string;\r\n       encode(codePoints: number[]): string;\r\n   }\r\n   export var version;\r\n}\r\n\r\ndeclare module \"repl\" {\r\n   import stream = module(\"stream\");\r\n   import events = module(\"events\");\r\n\r\n   export interface ReplOptions {\r\n       prompt?: string;\r\n       input?: stream.ReadableStream;\r\n       output?: stream.WritableStream;\r\n       terminal?: bool;\r\n       eval?: Function;\r\n       useColors?: bool;\r\n       useGlobal?: bool;\r\n       ignoreUndefined?: bool;\r\n       writer?: Function;\r\n   }\r\n   export function start(options: ReplOptions): events.NodeEventEmitter;\r\n}\r\n\r\ndeclare module \"readline\" {\r\n   import events = module(\"events\");\r\n   import stream = module(\"stream\");\r\n\r\n   export interface ReadLine extends events.NodeEventEmitter {\r\n       setPrompt(prompt: string, length: number): void;\r\n       prompt(preserveCursor?: bool): void;\r\n       question(query: string, callback: Function): void;\r\n       pause(): void;\r\n       resume(): void;\r\n       close(): void;\r\n       write(data: any, key?: any): void;\r\n   }\r\n   export interface ReadLineOptions {\r\n       input: stream.ReadableStream;\r\n       output: stream.WritableStream;\r\n       completer?: Function;\r\n       terminal?: bool;\r\n   }\r\n   export function createInterface(options: ReadLineOptions): ReadLine;\r\n}\r\n\r\ndeclare module \"vm\" {\r\n   export interface Context { }\r\n   export interface Script {\r\n       runInThisContext(): void;\r\n       runInNewContext(sandbox?: Context): void;\r\n   }\r\n   export function runInThisContext(code: string, filename?: string): void;\r\n   export function runInNewContext(code: string, sandbox?: Context, filename?: string): void;\r\n   export function runInContext(code: string, context: Context, filename?: string): void;\r\n   export function createContext(initSandbox?: Context): Context;\r\n   export function createScript(code: string, filename?: string): Script;\r\n}\r\n\r\ndeclare module \"child_process\" {\r\n   import events = module(\"events\");\r\n   import stream = module(\"stream\");\r\n\r\n   export interface ChildProcess extends events.NodeEventEmitter {\r\n       stdin: stream.WritableStream;\r\n       stdout: stream.ReadableStream;\r\n       stderr: stream.ReadableStream;\r\n       pid: number;\r\n       kill(signal?: string): void;\r\n       send(message: any, sendHandle: any): void;\r\n       disconnect(): void;\r\n   }\r\n\r\n   export function spawn(command: string, args?: string[], options?: {\r\n       cwd?: string;\r\n       stdio?: any;\r\n       custom?: any;\r\n       env?: any;\r\n       detached?: bool;\r\n   }): ChildProcess;\r\n   export function exec(command: string, options: {\r\n       cwd?: string;\r\n       stdio?: any;\r\n       customFds?: any;\r\n       env?: any;\r\n       encoding?: string;\r\n       timeout?: number;\r\n       maxBuffer?: number;\r\n       killSignal?: string;\r\n   }, callback: (error: Error, stdout: NodeBuffer, stderr: NodeBuffer) =>void ): ChildProcess;\r\n   export function exec(command: string, callback: (error: Error, stdout: NodeBuffer, stderr: NodeBuffer) =>void ): ChildProcess;\r\n   export function execFile(file: string, args: string[], options: {\r\n       cwd?: string;\r\n       stdio?: any;\r\n       customFds?: any;\r\n       env?: any;\r\n       encoding?: string;\r\n       timeout?: number;\r\n       maxBuffer?: string;\r\n       killSignal?: string;\r\n   }, callback: (error: Error, stdout: NodeBuffer, stderr: NodeBuffer) =>void ): ChildProcess;\r\n   export function fork(modulePath: string, args?: string[], options?: {\r\n       cwd?: string;\r\n       env?: any;\r\n       encoding?: string;\r\n   }): ChildProcess;\r\n}\r\n\r\ndeclare module \"url\" {\r\n   export interface Url {\r\n       href: string;\r\n       protocol: string;\r\n       auth: string;\r\n       hostname: string;\r\n       port: string;\r\n       host: string;\r\n       pathname: string;\r\n       search: string;\r\n       query: string;\r\n       slashes: bool;\r\n   }\r\n\r\n   export function parse(urlStr: string, parseQueryString? , slashesDenoteHost? ): Url;\r\n   export function format(url: Url): string;\r\n   export function resolve(from: string, to: string): string;\r\n}\r\n\r\ndeclare module \"dns\" {\r\n   export function lookup(domain: string, family: number, callback: (err: Error, address: string, family: number) =>void ): string;\r\n   export function lookup(domain: string, callback: (err: Error, address: string, family: number) =>void ): string;\r\n   export function resolve(domain: string, rrtype: string, callback: (err: Error, addresses: string[]) =>void ): string[];\r\n   export function resolve(domain: string, callback: (err: Error, addresses: string[]) =>void ): string[];\r\n   export function resolve4(domain: string, callback: (err: Error, addresses: string[]) =>void ): string[];\r\n   export function resolve6(domain: string, callback: (err: Error, addresses: string[]) =>void ): string[];\r\n   export function resolveMx(domain: string, callback: (err: Error, addresses: string[]) =>void ): string[];\r\n   export function resolveTxt(domain: string, callback: (err: Error, addresses: string[]) =>void ): string[];\r\n   export function resolveSrv(domain: string, callback: (err: Error, addresses: string[]) =>void ): string[];\r\n   export function resolveNs(domain: string, callback: (err: Error, addresses: string[]) =>void ): string[];\r\n   export function resolveCname(domain: string, callback: (err: Error, addresses: string[]) =>void ): string[];\r\n   export function reverse(ip: string, callback: (err: Error, domains: string[]) =>void ): string[];\r\n}\r\n\r\ndeclare module \"net\" {\r\n   import stream = module(\"stream\");\r\n\r\n   export interface NodeSocket extends stream.ReadWriteStream {\r\n       // Extended base methods\r\n       write(str: string, encoding?: string, fd?: string): bool;\r\n       write(buffer: NodeBuffer): bool;\r\n\r\n       connect(port: number, host?: string, connectionListener?: Function): void;\r\n       connect(path: string, connectionListener?: Function): void;\r\n       bufferSize: number;\r\n       setEncoding(encoding?: string): void;\r\n       write(data: any, encoding?: string, callback?: Function): void;\r\n       end(data?: any, encoding?: string): void;\r\n       destroy(): void;\r\n       pause(): void;\r\n       resume(): void;\r\n       setTimeout(timeout: number, callback?: Function); void;\r\n       setNoDelay(noDelay?: bool): void;\r\n       setKeepAlive(enable?: bool, initialDelay?: number): void;\r\n       address(): { port: number; family: string; address: string; };\r\n       remoteAddress: string;\r\n       remotePort: number;\r\n       bytesRead: number;\r\n       bytesWritten: number;\r\n   }\r\n\r\n   export var Socket: {\r\n       new (options?: { fd?: string; type?: string; allowHalfOpen?: bool; }): NodeSocket;\r\n   };\r\n\r\n   export interface Server extends NodeSocket {\r\n       listen(port: number, host?: string, backlog?: number, listeningListener?: Function): void;\r\n       listen(path: string, listeningListener?: Function): void;\r\n       listen(handle: any, listeningListener?: Function): void;\r\n       close(callback?: Function): void;\r\n       address(): { port: number; family: string; address: string; };\r\n       maxConnections: number;\r\n       connections: number;\r\n   }\r\n   export function createServer(connectionListener?: (socket: NodeSocket) =>void ): Server;\r\n   export function createServer(options?: { allowHalfOpen?: bool; }, connectionListener?: (socket: NodeSocket) =>void ): Server;\r\n   export function connect(options: { allowHalfOpen?: bool; }, connectionListener?: Function): void;\r\n   export function connect(port: number, host?: string, connectionListener?: Function): void;\r\n   export function connect(path: string, connectionListener?: Function): void;\r\n   export function createConnection(options: { allowHalfOpen?: bool; }, connectionListener?: Function): void;\r\n   export function createConnection(port: number, host?: string, connectionListener?: Function): void;\r\n   export function createConnection(path: string, connectionListener?: Function): void;\r\n   export function isIP(input: string): number;\r\n   export function isIPv4(input: string): bool;\r\n   export function isIPv6(input: string): bool;\r\n}\r\n\r\ndeclare module \"dgram\" {\r\n   import events = module(\"events\");\r\n\r\n   export function createSocket(type: string, callback?: Function): Socket;\r\n\r\n   interface Socket extends events.NodeEventEmitter {\r\n       send(buf: NodeBuffer, offset: number, length: number, port: number, address: string, callback?: Function): void;\r\n       bind(port: number, address?: string): void;\r\n       close(): void;\r\n       address: { address: string; family: string; port: number; };\r\n       setBroadcast(flag: bool): void;\r\n       setMulticastTTL(ttl: number): void;\r\n       setMulticastLoopback(flag: bool): void;\r\n       addMembership(multicastAddress: string, multicastInterface?: string): void;\r\n       dropMembership(multicastAddress: string, multicastInterface?: string): void;\r\n   }\r\n}\r\n\r\ndeclare module \"fs\" {\r\n   import stream = module(\"stream\");\r\n\r\n   interface Stats {\r\n       isFile(): bool;\r\n       isDirectory(): bool;\r\n       isBlockDevice(): bool;\r\n       isCharacterDevice(): bool;\r\n       isSymbolicLink(): bool;\r\n       isFIFO(): bool;\r\n       isSocket(): bool;\r\n       dev: number;\r\n       ino: number;\r\n       mode: number;\r\n       nlink: number;\r\n       uid: number;\r\n       gid: number;\r\n       rdev: number;\r\n       size: number;\r\n       blksize: number;\r\n       blocks: number;\r\n       atime: Date;\r\n       mtime: Date;\r\n       ctime: Date;\r\n   }\r\n\r\n   interface FSWatcher {\r\n       close(): void;\r\n   }\r\n\r\n   export interface ReadStream extends stream.ReadableStream { }\r\n   export interface WriteStream extends stream.WritableStream { }\r\n\r\n   export function rename(oldPath: string, newPath: string, callback?: Function): void;\r\n   export function renameSync(oldPath: string, newPath: string): void;\r\n   export function truncate(fd: string, len: number, callback?: Function): void;\r\n   export function truncateSync(fd: string, len: number): void;\r\n   export function chown(path: string, uid: number, gid: number, callback?: Function): void;\r\n   export function chownSync(path: string, uid: number, gid: number): void;\r\n   export function fchown(fd: string, uid: number, gid: number, callback?: Function): void;\r\n   export function fchownSync(fd: string, uid: number, gid: number): void;\r\n   export function lchown(path: string, uid: number, gid: number, callback?: Function): void;\r\n   export function lchownSync(path: string, uid: number, gid: number): void;\r\n   export function chmod(path: string, mode: string, callback?: Function): void;\r\n   export function chmodSync(path: string, mode: string): void;\r\n   export function fchmod(fd: string, mode: string, callback?: Function): void;\r\n   export function fchmodSync(fd: string, mode: string): void;\r\n   export function lchmod(path: string, mode: string, callback?: Function): void;\r\n   export function lchmodSync(path: string, mode: string): void;\r\n   export function stat(path: string, callback?: (err: Error, stats: Stats) =>any): Stats;\r\n   export function lstat(path: string, callback?: (err: Error, stats: Stats) =>any): Stats;\r\n   export function fstat(fd: string, callback?: (err: Error, stats: Stats) =>any): Stats;\r\n   export function statSync(path: string): Stats;\r\n   export function lstatSync(path: string): Stats;\r\n   export function fstatSync(fd: string): Stats;\r\n   export function link(srcpath: string, dstpath: string, callback?: Function): void;\r\n   export function linkSync(srcpath: string, dstpath: string): void;\r\n   export function symlink(srcpath: string, dstpath: string, type?: string, callback?: Function): void;\r\n   export function symlinkSync(srcpath: string, dstpath: string, type?: string): void;\r\n   export function readlink(path: string, callback?: (err: Error, linkString: string) =>any): void;\r\n   export function realpath(path: string, callback?: (err: Error, resolvedPath: string) =>any): void;\r\n   export function realpath(path: string, cache: string, callback: (err: Error, resolvedPath: string) =>any): void;\r\n   export function realpathSync(path: string, cache?: string): void;\r\n   export function unlink(path: string, callback?: Function): void;\r\n   export function unlinkSync(path: string): void;\r\n   export function rmdir(path: string, callback?: Function): void;\r\n   export function rmdirSync(path: string): void;\r\n   export function mkdir(path: string, mode?: string, callback?: Function): void;\r\n   export function mkdirSync(path: string, mode?: string): void;\r\n   export function readdir(path: string, callback?: (err: Error, files: string[]) => void): void;\r\n   export function readdirSync(path: string): string[];\r\n   export function close(fd: string, callback?: Function): void;\r\n   export function closeSync(fd: string): void;\r\n   export function open(path: string, flags: string, mode?: string, callback?: (err: Error, fd: string) =>any): void;\r\n   export function openSync(path: string, flags: string, mode?: string): void;\r\n   export function utimes(path: string, atime: number, mtime: number, callback?: Function): void;\r\n   export function utimesSync(path: string, atime: number, mtime: number): void;\r\n   export function futimes(fd: string, atime: number, mtime: number, callback?: Function): void;\r\n   export function futimesSync(fd: string, atime: number, mtime: number): void;\r\n   export function fsync(fd: string, callback?: Function): void;\r\n   export function fsyncSync(fd: string): void;\r\n   export function write(fd: string, buffer: NodeBuffer, offset: number, length: number, position: number, callback?: (err: Error, written: number, buffer: NodeBuffer) =>any): void;\r\n   export function writeSync(fd: string, buffer: NodeBuffer, offset: number, length: number, position: number): void;\r\n   export function read(fd: string, buffer: NodeBuffer, offset: number, length: number, position: number, callback?: (err: Error, bytesRead: number, buffer: NodeBuffer) => void): void;\r\n   export function readSync(fd: string, buffer: NodeBuffer, offset: number, length: number, position: number): any[];\r\n   export function readFile(filename: string, encoding: string, callback: (err: Error, data: NodeBuffer) => void ): void;\r\n   export function readFile(filename: string, callback: (err: Error, data: NodeBuffer) => void ): void;\r\n   export function readFileSync(filename: string): NodeBuffer;\r\n   export function readFileSync(filename: string, encoding: string): String;\r\n   export function writeFile(filename: string, data: any, encoding?: string, callback?: Function): void;\r\n   export function writeFileSync(filename: string, data: any, encoding?: string): void;\r\n   export function appendFile(filename: string, data: any, encoding?: string, callback?: Function): void;\r\n   export function appendFileSync(filename: string, data: any, encoding?: string): void;\r\n   export function watchFile(filename: string, listener: { curr: Stats; prev: Stats; }): void;\r\n   export function watchFile(filename: string, options: { persistent?: bool; interval?: number; }, listener: { curr: Stats; prev: Stats; }): void;\r\n   export function unwatchFile(filename: string, listener?: Stats): void;\r\n   export function watch(filename: string, options?: { persistent?: bool; }, listener?: (event: string, filename: string) =>any): FSWatcher;\r\n   export function exists(path: string, callback?: (exists: bool) =>void ): void;\r\n   export function existsSync(path: string): bool;\r\n   export function createReadStream(path: string, options?: {\r\n       flags?: string;\r\n       encoding?: string;\r\n       fd?: string;\r\n       mode?: number;\r\n       bufferSize?: number;\r\n   }): ReadStream;\r\n   export function createWriteStream(path: string, options?: {\r\n       flags?: string;\r\n       encoding?: string;\r\n       string?: string;\r\n   }): WriteStream;\r\n}\r\n\r\ndeclare module \"path\" {\r\n   export function normalize(p: string): string;\r\n   export function join(...paths: any[]): string;\r\n   export function resolve(from: string, to: string): string;\r\n   export function resolve(from: string, from2: string, to: string): string;\r\n   export function resolve(from: string, from2: string, from3: string, to: string): string;\r\n   export function resolve(from: string, from2: string, from3: string, from4: string, to: string): string;\r\n   export function resolve(from: string, from2: string, from3: string, from4: string, from5: string, to: string): string;\r\n   export function relative(from: string, to: string): string;\r\n   export function dirname(p: string): string;\r\n   export function basename(p: string, ext?: string): string;\r\n   export function extname(p: string): string;\r\n   export var sep: string;\r\n}\r\n\r\ndeclare module \"string_decoder\" {\r\n   export interface NodeStringDecoder {\r\n       write(buffer: NodeBuffer): string;\r\n       detectIncompleteChar(buffer: NodeBuffer): number;\r\n   }\r\n   export var StringDecoder: {\r\n       new (encoding: string): NodeStringDecoder;\r\n   };\r\n}\r\n\r\ndeclare module \"tls\" {\r\n   import crypto = module(\"crypto\");\r\n   import net = module(\"net\");\r\n   import stream = module(\"stream\");\r\n\r\n   var CLIENT_RENEG_LIMIT: number;\r\n   var CLIENT_RENEG_WINDOW: number;\r\n\r\n   export interface TlsOptions {\r\n       pfx?: any;   //string or buffer\r\n       key?: any;   //string or buffer\r\n       passphrase?: string;\r\n       cert?: any;\r\n       ca?: any;    //string or buffer\r\n       crl?: any;   //string or string array\r\n       ciphers?: string;\r\n       honorCipherOrder?: any;\r\n       requestCert?: bool;\r\n       rejectUnauthorized?: bool;\r\n       NPNProtocols?: any;  //array or Buffer;\r\n       SNICallback?: (servername: string) => any;\r\n   }\r\n\r\n   export interface ConnectionOptions {\r\n       host?: string;\r\n       port?: number;\r\n       socket?: net.NodeSocket;\r\n       pfx?: any;   //string | Buffer\r\n       key?: any;   //string | Buffer\r\n       passphrase?: string;\r\n       cert?: any;  //string | Buffer\r\n       ca?: any;    //Array of string | Buffer\r\n       rejectUnauthorized?: bool;\r\n       NPNProtocols?: any;  //Array of string | Buffer\r\n       servername?: string;\r\n   }\r\n\r\n   export interface Server extends net.Server {\r\n       // Extended base methods\r\n       listen(port: number, host?: string, backlog?: number, listeningListener?: Function): void;\r\n       listen(path: string, listeningListener?: Function): void;\r\n       listen(handle: any, listeningListener?: Function): void;\r\n\r\n       listen(port: number, host?: string, callback?: Function): void;\r\n       close(): void;\r\n       address(): { port: number; family: string; address: string; };\r\n       addContext(hostName: string, credentials: {\r\n           key: string;\r\n           cert: string;\r\n           ca: string;\r\n       }): void;\r\n       maxConnections: number;\r\n       connections: number;\r\n   }\r\n\r\n   export interface ClearTextStream extends stream.ReadWriteStream {\r\n       authorized: bool;\r\n       authorizationError: Error;\r\n       getPeerCertificate(): any;\r\n       getCipher: {\r\n           name: string;\r\n           version: string;\r\n       };\r\n       address: {\r\n           port: number;\r\n           family: string;\r\n           address: string;\r\n       };\r\n       remoteAddress: string;\r\n       remotePort: number;\r\n   }\r\n\r\n   export interface SecurePair {\r\n       encrypted: any;\r\n       cleartext: any;\r\n   }\r\n\r\n   export function createServer(options: TlsOptions, secureConnectionListener?: (cleartextStream: ClearTextStream) =>void ): Server;\r\n   export function connect(options: TlsOptions, secureConnectionListener?: () =>void ): ClearTextStream;\r\n   export function connect(port: number, host?: string, options?: ConnectionOptions, secureConnectListener?: () =>void ): ClearTextStream;\r\n   export function connect(port: number, options?: ConnectionOptions, secureConnectListener?: () =>void ): ClearTextStream;\r\n   export function createSecurePair(credentials?: crypto.Credentials, isServer?: bool, requestCert?: bool, rejectUnauthorized?: bool): SecurePair;\r\n}\r\n\r\ndeclare module \"crypto\" {\r\n   export interface CredentialDetails {\r\n       pfx: string;\r\n       key: string;\r\n       passphrase: string;\r\n       cert: string;\r\n       ca: any;    //string | string array\r\n       crl: any;   //string | string array\r\n       ciphers: string;\r\n   }\r\n   export interface Credentials { context?: any; }\r\n   export function createCredentials(details: CredentialDetails): Credentials;\r\n   export function createHash(algorithm: string): Hash;\r\n   interface Hash {\r\n       update(data: any, input_encoding?: string): void;\r\n       digest(encoding?: string): void;\r\n       createHmac(algorithm: string, key: string): Hmac;\r\n   }\r\n   interface Hmac {\r\n       update(data: any): void;\r\n       digest(encoding?: string): void;\r\n   }\r\n   export function createCipher(algorithm: string, password: any): Cipher;\r\n   export function createCipheriv(algorithm: string, key: any, iv: any): Cipher;\r\n   interface Cipher {\r\n       update(data: any, input_encoding?: string, output_encoding?: string): string;\r\n       final(output_encoding?: string): string;\r\n       setAutoPadding(auto_padding: bool): void;\r\n       createDecipher(algorithm: string, password: any): Decipher;\r\n       createDecipheriv(algorithm: string, key: any, iv: any): Decipher;\r\n   }\r\n   interface Decipher {\r\n       update(data: any, input_encoding?: string, output_encoding?: string): void;\r\n       final(output_encoding?: string): string;\r\n       setAutoPadding(auto_padding: bool): void;\r\n   }\r\n   export function createSign(algorithm: string): Signer;\r\n   interface Signer {\r\n       update(data: any): void;\r\n       sign(private_key: string, output_format: string): string;\r\n   }\r\n   export function createVerify(algorith: string): Verify;\r\n   interface Verify {\r\n       update(data: any): void;\r\n       verify(object: string, signature: string, signature_format?: string): bool;\r\n   }\r\n   export function createDiffieHellman(prime_length: number): DiffieHellman;\r\n   export function createDiffieHellman(prime: number, encoding?: string): DiffieHellman;\r\n   interface DiffieHellman {\r\n       generateKeys(encoding?: string): string;\r\n       computeSecret(other_public_key: string, input_encoding?: string, output_encoding?: string): string;\r\n       getPrime(encoding?: string): string;\r\n       getGenerator(encoding: string): string;\r\n       getPublicKey(encoding?: string): string;\r\n       getPrivateKey(encoding?: string): string;\r\n       setPublicKey(public_key: string, encoding?: string): void;\r\n       setPrivateKey(public_key: string, encoding?: string): void;\r\n   }\r\n   export function getDiffieHellman(group_name: string): DiffieHellman;\r\n   export function pbkdf2(password: string, salt: string, iterations: number, keylen: number, callback: (err: Error, derivedKey: string) => any): void;\r\n   export function randomBytes(size: number, callback?: (err: Error, buf: NodeBuffer) =>void );\r\n}\r\n\r\ndeclare module \"stream\" {\r\n   import events = module(\"events\");\r\n\r\n   export interface WritableStream extends events.NodeEventEmitter {\r\n       writable: bool;\r\n       write(str: string, encoding?: string, fd?: string): bool;\r\n       write(buffer: NodeBuffer): bool;\r\n       end(): void;\r\n       end(str: string, enconding: string): void;\r\n       end(buffer: NodeBuffer): void;\r\n       destroy(): void;\r\n       destroySoon(): void;\r\n   }\r\n\r\n   export interface ReadableStream extends events.NodeEventEmitter {\r\n       readable: bool;\r\n       setEncoding(encoding: string): void;\r\n       pause(): void;\r\n       resume(): void;\r\n       destroy(): void;\r\n       pipe(destination: WritableStream, options?: { end?: bool; }): void;\r\n   }\r\n\r\n   export interface ReadWriteStream extends ReadableStream, WritableStream { }\r\n}\r\n\r\ndeclare module \"util\" {\r\n   export function format(format: any, ...param: any[]): string;\r\n   export function debug(string: string): void;\r\n   export function error(...param: any[]): void;\r\n   export function puts(...param: any[]): void;\r\n   export function print(...param: any[]): void;\r\n   export function log(string: string): void;\r\n   export function inspect(object: any, showHidden?: bool, depth?: number, color?: bool): void;\r\n   export function isArray(object: any): bool;\r\n   export function isRegExp(object: any): bool;\r\n   export function isDate(object: any): bool;\r\n   export function isError(object: any): bool;\r\n   export function inherits(constructor: any, superConstructor: any): void;\r\n}\r\n\r\ndeclare module \"assert\" {\r\n   export function fail(actual: any, expected: any, message: string, operator: string): void;\r\n   export function assert(value: any, message: string): void;\r\n   export function ok(value: any, message?: string): void;\r\n   export function equal(actual: any, expected: any, message?: string): void;\r\n   export function notEqual(actual: any, expected: any, message?: string): void;\r\n   export function deepEqual(actual: any, expected: any, message?: string): void;\r\n   export function notDeepEqual(acutal: any, expected: any, message?: string): void;\r\n   export function strictEqual(actual: any, expected: any, message?: string): void;\r\n   export function notStrictEqual(actual: any, expected: any, message?: string): void;\r\n   export function throws(block: any, error?: any, messsage?: string): void;\r\n   export function doesNotThrow(block: any, error?: any, messsage?: string): void;\r\n   export function ifError(value: any): void;\r\n}\r\n\r\ndeclare module \"tty\" {\r\n   import net = module(\"net\");\r\n\r\n   export function isatty(fd: string): bool;\r\n   export interface ReadStream extends net.NodeSocket {\r\n       isRaw: bool;\r\n       setRawMode(mode: bool): void;\r\n   }\r\n   export interface WriteStream extends net.NodeSocket {\r\n       columns: number;\r\n       rows: number;\r\n   }\r\n}\r\n\r\ndeclare module \"domain\" {\r\n   import events = module(\"events\");\r\n\r\n   export interface Domain extends events.NodeEventEmitter { }\r\n\r\n   export function create(): Domain;\r\n   export function run(fn: Function): void;\r\n   export function add(emitter: events.NodeEventEmitter): void;\r\n   export function remove(emitter: events.NodeEventEmitter): void;\r\n   export function bind(cb: (er: Error, data: any) =>any): any;\r\n   export function intercept(cb: (data: any) => any): any;\r\n   export function dispose(): void;\r\n}"]],"start1":0,"start2":0,"length1":0,"length2":44057}]],"length":44057,"saved":false}

{"ts":1347011207376,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"#require 'longjohn'\nflow = require 'flow'\ndef = flow.define\nex = flow.exec\nroot_path = if __dirname.indexOf 'build' then '../../../' else '../../'\ncontracts = ~__dirname.indexOf '-ctrs'\nsettings = require \"#{root_path}settings\"\n{ ImapConnection } = require \"imap\"\nutil = require \"util\"\nrepl = require 'repl'\nPromise = require 'when'\nif contracts \n\t{\n\t\tGmailCtr\n\t\tGmailManagerCtr\n\t} = require './updates_contracts'\nprop = require('jsprops').property\nrequire 'sugar'\n\n# TODO config\nObject.merge settings, gmail_max_results: 300\n\n# TODO add event emitter\nclass BaseClass\n\trepl: ->\n\t\trepl = repl.start(\n\t\t\t\tprompt: \"repl> \"\n\t\t\t\tinput: process.stdin\n\t\t\t\toutput: process.stdout\n\t\t\t)\n\t\trepl.context.this = @\n\n\tlog: -> console.log.apply console, arguments\n\n###\nTODO emit:\n- new-msg msg\n- changed-label {msg, new_labels, removed_labels}\n###\n\nclass GmailSearch extends BaseClass \n\tname: \"\"\n\tactive: yes\n\tlast_update: 0\n\tupdate_interval: 10*1000\n\tmanager: null\n\tmonitored_: prop('monitored_', null, [])\n\t\n\tconstructor: (@manager, @name, update_interval) ->\n\t\tupdate_interval ?= @update_interval\n\t\t@log \"creating a serch for '#{name}' with interval=#{update_interval}\"\n\t\t@update_interval = update_interval\n\t\t\n\tfetch: (next) ->\n\t\t@log \"performing a search for #{@name}\"\n\t\tdeferred = Promise.defer()\n\t\tif next\n\t\t\tdeferred.promise.then next\n\t\t@query_ deferred\n\t\tdeferred.promise\n\n\tquery_: (deferred) ->\n\t\timap = @manager.connection\n\t\timap.search [ [ 'X-GM-RAW', @name ] ], (err, results) =>\n\t\t\t@results_ deferred, err, results \n\n\tresults_: (deferred, err, results) ->\n\t\timap = @manager.connection\n\t\t# TODO labels\n\t\t@log 'got search results'\n\t\tcontent = headers: [ \"id\", \"from\", \"to\", \"subject\", \"date\" ]\n\t\tfetch = imap.fetch results, content\n\t\tfetch.on \"message\", (msg) =>\n#\t\t\t\t\tmsg.on \"data\", (chunk) =>\n#\t\t\t\t\t\t@log \"Got message chunk of size \" + chunk.length\n\t\t\tmsg.on \"end\", =>\n#\t\t\t\t@log \"Finished message: \" + util.inspect msg, false, 5\n\t\t\t\tif !~ @monitored_().indexOf msg.id\n\t\t\t\t\t# TODO event\n\t\t\t\t\t@log 'new msg'\n\t\t\t\t\t@monitored_().push msg.id\n\t\t\t\t\t# TODO later\n\t\t\t\t\t# @emit \"new-msg\"\n#\t\t\t\t\telse\n#\t\t\t\t\t\t# TODO compare labels\n#\t\t\t\t\t\t# TODO check new msgs in the thread\n\t\tfetch.on \"end\", (err) =>\n\t\t\t@log 'fetch ended'\n\t\t\tdeferred.resolve()\n\t\tfetch.on \"error\", (err) =>\n\t\t\t# new Error ???\n\t\t\tdeferred.reject err\n\n###*\nMissing:\n- global lock\n###\nclass GmailManager extends BaseClass \n\tlocked: no\n\tsearches: prop('searches', null, [])\n\tconnection: null\n\tsettings: null\n\t\t\n\tconstructor: (@settings, next) ->\n\t\t# TODO no auto connect \n\t\t@connect next\n\n\t\tdo @repl if settings.repl\n\n\taddSearch: (name, update_interval) ->\n\t\t@searches().push new GmailSearch @, name, update_interval\n\t\t\t\t\t\n\t# basic schedule implementation\n\tactivate: -> \n\t\tsearch = @searches().sortBy(\"last_update\").first()\n\t\t@log \"activating #{search.name}\"\n\t\tif @cursor_ >= @searches().length\n\t\t\t@cursor_ = 0\n\t\t# get promise resolvals for the interval and the request\n\t\tresolve = (Promise.defer() for i in [0, 1])\n\t\tsetTimeout resolve[0].resolve, @minInterval_()\n\t\t# run the search query\n\t\tsearch.fetch resolve[1].resolve\n\t\t# run activate once more after both promises are fulfilled\n\t\tPromise.all(resolve).then @activate.bind @\n\t\t\t\t\t\n\tminInterval_: ->\n\t\t(Math.min ch.update_interval for ch in @searches())[0]\n\n\tconnect: def(\n\t\t(@next) ->\n\t\t\t@this.log 'connecting'\n\t\t\tdata = @this.settings\n\t\t\t@this.connection = new ImapConnection\n\t\t\t\tusername: data.gmail_username\n\t\t\t\tpassword: data.gmail_password \n\t\t\t\thost: data.gmail_host or \"imap.gmail.com\"\n\t\t\t\tport: 993\n\t\t\t\tsecure: true\n\t\t\t@this.connection.connect @\n\t\t->\n\t\t\t@this.connection.openBox \"[Gmail]/All Mail\", false, @next\n\t)\n\t\n\tdisconnect: -> @connection.logout\n\n#if contracts\n#\tGmail.Manager :: GmailManagerCtr\n#\tGmail.Manager = Gmail.Manager\n#\t\n#\tfor prop, ctr of GmailCtr.oc\n#\t\t\tcontinue if not Gmail::[prop] or\n#\t\t\t\t\tprop is 'constructor'\n#\t\t\tGmail::[prop] :: ctr\n#\t\t\tGmail::[prop] = Gmail::[prop]\n\ngmail = null\nex(\n\t-> gmail = new GmailManager settings, @\n\t->\n\t\tgmail.addSearch '*', 5000\n\t\tgmail.activate()\n)\nsetTimeout gmail.disconnect.bind gmail, 10*1000\n"]],"start1":0,"start2":0,"length1":0,"length2":4061}]],"length":4061}

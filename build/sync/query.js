// Generated by CoffeeScript 1.8.0
(function() {
  var ILabel, IMessage, IMessagePart, IQuery, ITask, ITaskList, ITaskLists, ITasks, IThread, IThreads, Promise, Query, QueryStates, ago, coroutine, moment, timestamp, type, typedef, _ref,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  QueryStates = require('./query-states');

  _ref = require('./api-types'), ITaskList = _ref.ITaskList, ITaskLists = _ref.ITaskLists, IQuery = _ref.IQuery, IThread = _ref.IThread, IThreads = _ref.IThreads, ITask = _ref.ITask, ITasks = _ref.ITasks, IMessage = _ref.IMessage, IMessagePart = _ref.IMessagePart, ILabel = _ref.ILabel;

  Promise = require('bluebird');

  coroutine = Promise.coroutine;

  type = require('../type');

  typedef = require('tracery');

  timestamp = require('internet-timestamp');

  ago = require('ago');

  moment = require('moment');

  module.exports = Query = (function() {
    Query.prototype.data = null;

    Query.prototype.name = null;

    Query.prototype.list = null;

    Query.defineType('list', ITaskList, 'ITaskList');

    Query.prototype.tasks_api = null;

    Query.prototype.states = null;

    Query.prototype.labels = null;

    Query.prototype.tasks = null;

    Query.prototype.tasks_in_threads = null;

    Query.prototype.tasks_completed = null;

    Query.prototype.threads = null;

    Query.defineType('labels', [ILabel], '[ILabel]');

    Query.prototype.sync = null;

    Query.prototype.etags = null;

    Query.prototype.seen_threads = null;

    Query.prototype.completions_threads = null;

    Query.prototype.completions_tasks = null;

    function Query(name, data, sync) {
      this.name = name;
      this.data = data;
      this.sync = sync;
      this.states = new QueryStates;
      if (this.sync.config.debug) {
        this.states.debug('Query / ', this.sync.config.debug);
      }
      this.states.setTarget(this);
      this.gmail_api = this.sync.gmail_api;
      this.tasks_api = this.sync.tasks_api;
      this.tasks_in_threads = [];
      this.tasks = [];
      this.threads = [];
      this.etags = {};
      this.completions_threads = {};
      this.completions_tasks = {};
    }

    Query.prototype.Restart_enter = function() {
      return this.states.add('Syncing');
    };

    Query.prototype.Synced_enter = function() {
      return setTimeout(this.states.addLater('Restart'), 5000);
    };

    Query.prototype.FetchingTasks_FetchingTasks = Query.FetchingTasks_enter;

    Query.prototype.SyncingThreadsToTasks_enter = coroutine(function*() {
      var interrupt;
      interrupt = this.states.getInterruptEnter('SyncingThreadsToTasks');
      (yield Promise.all(this.threads.threads.map(coroutine((function(_this) {
        return function*(thread) {
          var task, task_completed, thread_not_completed;
          task = _this.getTaskForThread(thread.id);
          if (task) {
            task_completed = _this.taskWasCompleted(task.id);
            thread_not_completed = _this.threadWasNotCompleted(thread.id);
            if (task_completed && task_completed.unix() < thread_not_completed.unix()) {
              (yield _this.uncompleteTask(task.id, interrupt));
            }
          } else {
            (yield _this.createTaskFromThread(thread, interrupt));
          }
          if (typeof interrupt === "function" ? interrupt() : void 0) {

          }
        };
      })(this)))));
      return this.states.add(['ThreadsToTasksSynced', 'Synced']);
    });

    Query.prototype.SyncingTasksToThreads_enter = coroutine(function*() {
      var interrupt;
      interrupt = this.states.getInterruptEnter('SyncingTasksToThreads');
      (yield Promise.all(this.tasks.items.map(coroutine((function(_this) {
        return function*(task) {
          var task_not_completed, thread, thread_completed, thread_id;
          if (!task.title || task.parent) {
            return;
          }
          thread_id = _this.taskLinkedToThread(task);
          if (thread_id) {
            thread_completed = _this.threadWasCompleted(thread_id);
            task_not_completed = _this.taskWasNotCompleted(task.id);
            if (thread_completed && thread_completed.unix() < task_not_completed.unix()) {
              return (yield _this.uncompleteThread(thread_id, interrupt));
            }
          } else {
            return thread = (yield _this.createThreadForTask(task, interrupt));
          }
        };
      })(this)))));
      if (interrupt()) {
        return;
      }
      return this.states.add(['TasksToThreadsSynced', 'Synced']);
    });

    Query.prototype.SyncingCompletedThreads_enter = coroutine(function*() {
      var interrupt;
      interrupt = this.states.getInterruptEnter('SyncingCompletedThreads');
      (yield Promise.all(this.completions_threads.map(coroutine((function(_this) {
        return function*(row, thread_id) {
          var task, task_not_completed;
          if (!row.completed) {
            return;
          }
          task = _this.getTaskForThread(thread_id);
          if (!task) {
            return;
          }
          task_not_completed = _this.taskWasNotCompleted(task.id);
          if (task_not_completed && row.time.unix() > task_not_completed.unix()) {
            return (yield _this.completeTask(task.id, interrupt));
          }
        };
      })(this)))));
      if (interrupt()) {
        return;
      }
      return this.states.add(['CompletedThreadsSynced', 'Synced']);
    });

    Query.prototype.SyncingCompletedTasks_enter = coroutine(function*() {
      var interrupt;
      interrupt = this.states.getInterruptEnter('SyncingCompletedTasks');
      (yield Promise.all(this.completions_tasks.map(coroutine((function(_this) {
        return function*(row, task_id) {
          var task, thread_id, thread_not_completed;
          if (!row.completed) {
            return;
          }
          task = _this.getTask(task_id);
          if (!task) {
            return;
          }
          thread_id = _this.taskLinkedToThread(task);
          thread_not_completed = _this.threadWasNotCompleted(thread_id);
          if (thread_not_completed && row.time.unix() > thread_not_completed.unix()) {
            return (yield _this.completeThread(thread_id, interrupt));
          }
        };
      })(this)))));
      if (interrupt()) {
        return;
      }
      return this.states.add(['CompletedTasksSynced', 'Synced']);
    });

    Query.prototype.PreparingList_enter = coroutine(function*() {
      var interrupt, list, r, _i, _len, _ref1;
      interrupt = this.states.getInterruptEnter('PreparingList');
      list = null;
      this.def_title = this.data.labels_in_title || this.sync.config.labels_in_title;
      _ref1 = this.sync.task_lists;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        r = _ref1[_i];
        if (this.name === r.title) {
          list = r;
          break;
        }
      }
      if (!list) {
        list = (yield this.createTaskList(this.name, interrupt));
        console.log("Creating tasklist '" + this.name + "'");
      }
      this.list = type(list, ITaskList, 'ITaskList');
      return this.states.add('ListReady');
    });

    Query.prototype.FetchingThreads_enter = coroutine(function*() {
      var interrupt, non_completed, query, res, threads;
      interrupt = this.states.getInterruptEnter('FetchingThreads');
      res = (yield this.req(this.gmail_api.users.threads.list, {
        q: this.data.query,
        userId: "me",
        etag: this.etags.threads
      }));
      if (typeof interrupt === "function" ? interrupt() : void 0) {
        return;
      }
      if (res[1].statusCode === 304) {
        console.log('[CACHED] threads');
        this.states.add('ThreadsFetched');
        return;
      }
      this.etags.threads = res[1].headers.etag;
      query = res[0];
      if (query.threads == null) {
        query.threads = [];
      }
      non_completed = [];
      threads = (yield Promise.all(query.threads.map((function(_this) {
        return function(thread) {
          var completion;
          non_completed.push(thread.id);
          completion = _this.completions_threads[thread.id];
          if ((completion != null ? completion.completed : void 0) || !completion) {
            _this.completions_threads[thread.id] = {
              completed: false,
              time: moment()
            };
          }
          return _this.req(_this.gmail_api.users.threads.get, {
            id: thread.id,
            userId: 'me',
            metadataHeaders: 'SUBJECT',
            format: 'metadata',
            fields: 'id,messages(id,labelIds,payload(headers))'
          });
        };
      })(this))));
      this.completions_threads.each(function(row, id) {
        if (__indexOf.call(non_completed, id) >= 0) {
          return;
        }
        if (!row.completed) {
          return;
        }
        row.completed = true;
        return row.time = moment();
      });
      if (typeof interrupt === "function" ? interrupt() : void 0) {
        return;
      }
      query.threads = threads.map(function(item) {
        return item[0];
      });
      this.threads = type(query, IThreads, 'IThreads');
      return this.states.add('ThreadsFetched');
    });

    Query.prototype.FetchingTasks_enter = coroutine(function*() {
      var action_res, completed_res, interrupt, requests, _base, _base1, _ref1;
      interrupt = this.states.getInterruptEnter('FetchingTasks');
      if (!this.tasks_completed_from || this.tasks_completed_from < ago(3, "weeks")) {
        this.tasks_completed_from = ago(2, "weeks");
      }
      requests = [];
      requests.push(this.req(this.tasks_api.tasks.list, {
        tasklist: this.list.id,
        fields: "etag,items(id,title,notes,updated,etag,status)",
        maxResults: 1000,
        showCompleted: false,
        etag: this.etags.tasks
      }));
      requests.push(this.req(this.tasks_api.tasks.list, {
        updatedMin: timestamp(new Date(this.tasks_completed_from)),
        tasklist: this.list.id,
        fields: "etag,items(id,title,notes,updated,etag,status,completed)",
        maxResults: 1000,
        showCompleted: true,
        etag: this.etags.tasks_completed
      }));
      _ref1 = (yield Promise.all(requests)), action_res = _ref1[0], completed_res = _ref1[1];
      if (typeof interrupt === "function" ? interrupt() : void 0) {
        return;
      }
      if (action_res[1].statusCode === 304) {
        console.log('[CACHED] tasks');
      } else {
        console.log('[FETCHED] tasks');
        this.etags.tasks = action_res[1].headers.etag;
        if ((_base = action_res[0]).items == null) {
          _base.items = [];
        }
        action_res[0].items.forEach((function(_this) {
          return function(task) {
            return _this.completions_tasks[task.id] = {
              completed: false,
              time: moment(task.completed)
            };
          };
        })(this));
        this.tasks = type(action_res[0], ITasks, 'ITasks');
      }
      if (completed_res[1].statusCode === 304) {
        console.log('[CACHED] completed tasks');
      } else {
        console.log('[FETCHED] completed tasks');
        this.etags.tasks_completed = completed_res[1].headers.etag;
        if ((_base1 = completed_res[0]).items == null) {
          _base1.items = [];
        }
        completed_res[0].items = completed_res[0].items.filter(function(item) {
          return item.status === 'completed';
        });
        completed_res[0].items.forEach((function(_this) {
          return function(task) {
            return _this.completions_tasks[task.id] = {
              completed: true,
              time: moment(task.completed)
            };
          };
        })(this));
        this.tasks_completed = type(completed_res[0], ITasks, 'ITasks');
      }
      return this.states.add('TasksFetched');
    });

    Query.prototype.completeThread = coroutine(function*(id, interrupt) {
      console.log("Completing thread '" + id + "'");
      (yield this.modifyLabels(id, [], this.uncompletedThreadLabels(), interrupt));
      if (typeof interrupt === "function" ? interrupt() : void 0) {
        return;
      }
      return this.completions_threads[id] = {
        completed: true,
        time: moment()
      };
    });

    Query.prototype.uncompleteThread = coroutine(function*(id, interrupt) {
      console.log("Un-completing thread '" + id + "'");
      (yield this.modifyLabels(id, this.uncompletedThreadLabels(), [], interrupt));
      if (typeof interrupt === "function" ? interrupt() : void 0) {
        return;
      }
      return this.completions_threads[id] = {
        completed: false,
        time: moment()
      };
    });

    Query.prototype.createThreadForTask = coroutine(function*(task, interrupt) {
      var res, thread;
      console.log("Creating email '" + task.title + "' (" + (this.uncompletedThreadLabels().join(', ')) + ")");
      res = (yield this.req(this.gmail_api.users.messages.insert, {
        userId: 'me',
        resource: {
          raw: this.createEmail(task.title),
          labelIds: this.getLabelsIds(this.uncompletedThreadLabels())
        }
      }));
      if (typeof interrupt === "function" ? interrupt() : void 0) {
        return;
      }
      thread = res[0];
      this.threads.threads.push(thread);
      if (typeof interrupt === "function" ? interrupt() : void 0) {
        return;
      }
      (yield this.linkTaskToThread(task, thread.id, interrupt));
      if (typeof interrupt === "function" ? interrupt() : void 0) {
        return;
      }
      return thread;
    });

    Query.prototype.taskLinkedToThread = function(task) {
      var _ref1, _ref2;
      if ((_ref1 = task.notes) != null ? _ref1.match(/\bemail:\w+\b/) : void 0) {
        return ((_ref2 = task.notes) != null ? _ref2.match(/\bemail:(\w+)\b/) : void 0)[1];
      }
    };

    Query.prototype.linkTaskToThread = coroutine(function*(task, thread_id, interrupt) {
      if (task.notes == null) {
        task.notes = "";
      }
      task.notes = "" + task.notes + "\nemail:" + thread_id;
      (yield this.req(this.tasks_api.tasks.patch, {
        tasklist: this.list.id,
        task: task.id,
        userId: 'me',
        resource: {
          notes: task.notes
        }
      }));
      if (typeof interrupt === "function" ? interrupt() : void 0) {

      }
    });

    Query.prototype.uncompletedThreadLabels = function() {
      var _ref1;
      return [].concat(this.data['labels_new_task'] || [], ((_ref1 = this.sync.config.tasks.queries.labels_defaults) != null ? _ref1['labels_new_task'] : void 0) || []);
    };

    Query.prototype.uncompleteTask = coroutine(function*(task_id, interrupt) {
      var res;
      console.log("Un-completing task " + task_id);
      res = (yield this.req(this.tasks_api.tasks.patch, {
        tasklist: this.list.id,
        task: task_id,
        resource: {
          status: 'needsAction',
          completed: null
        }
      }));
      if (typeof interrupt === "function" ? interrupt() : void 0) {
        return;
      }
      return this.completions_tasks[task_id] = {
        completed: false,
        time: moment()
      };
    });

    Query.prototype.completeTask = coroutine(function*(task_id, interrupt) {
      console.log("Completing task " + task_id);
      (yield this.req(this.tasks_api.tasks.patch, {
        tasklist: this.list.id,
        task: task_id,
        resource: {
          status: 'completed'
        }
      }));
      if (typeof interrupt === "function" ? interrupt() : void 0) {
        return;
      }
      return this.completions_tasks[task_id] = {
        completed: false,
        time: moment()
      };
    });

    Query.prototype.getAllTasks = function() {
      return this.tasks.items.concat(this.tasks_completed.items || []);
    };

    Query.prototype.fetchThreadForTask = coroutine(function*(task) {
      var res, thread_id, _ref1;
      thread_id = ((_ref1 = task.notes) != null ? _ref1.match(/\bemail:(\w+)\b/) : void 0)[1];
      res = (yield this.req(this.gmail_api.users.threads.get, {
        id: thread_id,
        userId: 'me'
      }));
      return res[0];
    });

    Query.prototype.req = coroutine(function*(method, params) {
      return (yield this.sync.req.apply(this.sync, arguments));
    });

    Query.prototype.syncTaskName = coroutine(function*(task, thread) {
      var res, title;
      title = thread.messages[0].payload.headers[0].value;
      title = this.getTaskTitleFromThread(thread);
      if (task.title !== title) {
        console.log("Updating task title to \"" + title + "\"");
        res = (yield this.req(this.tasks_api.tasks.patch, {
          tasklist: this.list.id,
          task: task.id,
          resource: {
            title: title
          }
        }));
        return task.title = title;
      }
    });

    Query.prototype.createTaskList = coroutine(function*(name, interrupt) {
      var res;
      res = (yield this.req(this.tasks_api.tasklists.insert, {
        resource: {
          title: name
        }
      }));
      return type(res[1].body, ITaskList, 'ITaskList');
    });

    Query.prototype.createTaskFromThread = coroutine(function*(thread, interrupt) {
      var res, title;
      type(thread, IThread, 'IThread');
      title = this.getTaskTitleFromThread(thread);
      console.log("Adding task '" + title + "'");
      res = (yield this.req(this.tasks_api.tasks.insert, {
        tasklist: this.list.id,
        resource: {
          title: title,
          notes: "email:" + thread.id
        }
      }));
      if (typeof interrupt === "function" ? interrupt() : void 0) {
        return;
      }
      return type(res[0], ITask, 'ITask');
    });

    Query.prototype.createEmail = function(subject) {
      var email;
      type(subject, String);
      email = ["From: " + this.sync.config.gmail_username + " <" + this.sync.config.gmail_username + ">s", "To: " + this.sync.config.gmail_username, "Content-type: text/html;charset=utf-8", "MIME-Version: 1.0", "Subject: " + subject].join("\r\n");
      return new Buffer(email).toString('base64').replace(/\+/g, '-').replace(/\//g, '_');
    };

    Query.prototype.getTask = function(task_id) {
      return this.getAllTasks().find(function(task) {
        return task.id === task_id;
      });
    };

    Query.prototype.getTaskForThread = function(thread_id) {
      var task;
      type(thread_id, String);
      task = this.getAllTasks().find(function(task) {
        var _ref1;
        return (_ref1 = task.notes) != null ? _ref1.match("email:" + thread_id) : void 0;
      });
      return type(task, ITask, 'ITask');
    };

    Query.prototype.getTaskTitleFromThread = function(thread) {
      var label, labels, title, _i, _len, _ref1, _ref2;
      type(thread, IThread, 'IThread');
      title = thread.messages[0].payload.headers[0].value;
      _ref1 = this.getlabelsFromTitle(title), title = _ref1[0], labels = _ref1[1];
      _ref2 = this.data.labels_new_task;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        label = _ref2[_i];
        labels = labels.without(label);
      }
      if (this.sync.config.tasks.labels_in_title === 1) {
        return labels.concat(title).join(' ');
      } else {
        return [title].concat(labels).join(' ');
      }
    };

    Query.prototype.getLabelsIds = function(labels) {
      if (!Object.isArray(labels)) {
        labels = [labels];
      }
      return labels.map((function(_this) {
        return function(name) {
          var label;
          label = _this.sync.labels.find(function(label) {
            return label.name.toLowerCase() === name.toLowerCase();
          });
          return label.id;
        };
      })(this));
    };


    /*
    	@name string
    	@return [ string, Array<Label> ]
     */

    Query.prototype.getlabelsFromTitle = function(title) {
      var label, labels, name, prefix, r, symbol, _i, _len, _ref1;
      type(title, String);
      labels = [];
      _ref1 = this.sync.config.auto_labels;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        r = _ref1[_i];
        symbol = r.symbol;
        label = r.label;
        prefix = r.prefix;
        name = r.shortcut ? r.shortcut : "\\w+";
        title = title.replace("\b" + symbol + "(" + name + ")\b", '', function(name) {
          return labels.push(prefix + (label || name));
        });
      }
      title = title.trim();
      type(name, String);
      type(labels, [String]);
      return [title, labels];
    };

    Query.prototype.modifyLabels = coroutine(function*(thread_id, add_labels, remove_labels, interrupt) {
      type(thread_id, String);
      if (add_labels == null) {
        add_labels = [];
      }
      if (remove_labels == null) {
        remove_labels = [];
      }
      console.log("Modifing labels for thread " + thread_id);
      (yield this.req(this.gmail_api.users.messages.modify, {
        id: thread_id,
        userId: 'me',
        resource: {
          addLabelIds: this.getLabelsIds(add_labels),
          removeLabelIds: this.getLabelsIds(remove_labels)
        }
      }));
      if (typeof interrupt === "function" ? interrupt() : void 0) {

      }
    });

    Query.prototype.labelByName = function(name) {
      type(this.sync.labels, [ILabel], '[ILabel]');
      return this.sync.labels.find(function(label) {
        return label.name === name;
      });
    };

    Query.prototype.threadHasLabels = function(thread, label) {
      var id, label_id, msg, _i, _j, _len, _len1, _ref1, _ref2;
      label = this.labelByName(label);
      type(label, ILabel, 'ILabel');
      id = label.id;
      _ref1 = thread.messages;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        msg = _ref1[_i];
        _ref2 = msg.labelIds;
        for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
          label_id = _ref2[_j];
          if (this.sync.labels.find(function(label) {
            return label.id === id;
          })) {
            return true;
          }
        }
      }
      return false;
    };

    Query.prototype.taskWasCompleted = function(id) {
      var _ref1;
      if (((_ref1 = this.completions_tasks[id]) != null ? _ref1.completed : void 0) === true) {
        return this.completions_tasks[id].time;
      } else {
        return false;
      }
    };

    Query.prototype.taskWasNotCompleted = function(id) {
      var _ref1;
      if (((_ref1 = this.completions_tasks[id]) != null ? _ref1.completed : void 0) === false) {
        return this.completions_tasks[id].time;
      } else {
        return false;
      }
    };

    Query.prototype.threadWasCompleted = function(id) {
      var _ref1;
      if (((_ref1 = this.completions_threads[id]) != null ? _ref1.completed : void 0) === true) {
        return this.completions_threads[id].time;
      } else {
        return false;
      }
    };

    Query.prototype.threadWasNotCompleted = function(id) {
      var _ref1;
      if (((_ref1 = this.completions_threads[id]) != null ? _ref1.completed : void 0) === false) {
        return this.completions_threads[id].time;
      } else {
        return false;
      }
    };

    return Query;

  })();

}).call(this);

// Generated by CoffeeScript 1.8.0
(function() {
  var IMessage, IMessagePart, IQuery, ITask, ITaskList, ITaskLists, ITasks, IThread, IThreads, Promise, States, Sync, async, asyncmachine, auth, coroutine, google, opt, promise_exception, promisify, type, typedef, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  auth = require('../auth');

  async = require('async');

  asyncmachine = require('asyncmachine');

  google = require('googleapis');

  Promise = require('bluebird');

  Promise.longStackTraces();

  coroutine = Promise.coroutine;

  promisify = Promise.promisify;

  typedef = require('tracery');

  opt = typedef.Optional;

  _ref = require('./api-types'), ITaskList = _ref.ITaskList, ITaskLists = _ref.ITaskLists, IQuery = _ref.IQuery, IThread = _ref.IThread, IThreads = _ref.IThreads, ITask = _ref.ITask, ITasks = _ref.ITasks, IMessage = _ref.IMessage, IMessagePart = _ref.IMessagePart;

  type = function(value, type, name) {
    if (Object.isArray(type)) {
      type = typedef(type);
    }
    if (!type(value)) {
      console.log(value);
      throw new TypeError(name || '');
    }
    return value;
  };

  promise_exception = function(e) {
    if (e.errors) {
      console.log(e.errors);
    }
    return console.log((e.stack.split("\n")).join("\n"));
  };

  States = (function(_super) {
    __extends(States, _super);

    function States() {
      States.__super__.constructor.apply(this, arguments);
      this.register('Ready', 'Authenticating', 'Authenticated', 'Syncing', 'Synced');
    }

    States.prototype.Ready = {
      auto: true,
      requires: ['Authenticated']
    };

    States.prototype.Authenticating = {
      blocks: ['Authenticated']
    };

    States.prototype.Authenticated = {
      blocks: ['Authenticating']
    };

    States.prototype.Syncing = {
      auto: true,
      requires: ['Ready'],
      blocks: ['Synced']
    };

    States.prototype.Synced = {
      blocks: ['Syncing']
    };

    return States;

  })(asyncmachine.AsyncMachine);

  Function.prototype.defineType = function(name, type, type_name) {
    return Object.defineProperty(this.prototype, name, {
      set: function(v) {
        type(v, ITaskLists, 'ITaskLists');
        return this.__task_lists = v;
      },
      get: function() {
        return this.__task_lists;
      }
    });
  };

  Sync = (function() {
    Sync.prototype.states = null;

    Sync.prototype.config = null;

    Sync.prototype.auth = null;

    Sync.prototype.tasks = null;

    Sync.prototype.gmail = null;

    Sync.prototype.task_lists = null;

    Sync.defineType('task_lists', ITaskLists, 'ITaskLists');

    function Sync(config) {
      this.config = config;
      this.states = new States;
      if (config.debug) {
        this.states.debug('Sync ', 2);
      }
      this.task_lists = [];
      this.labels = [];
      this.auth = new auth.Auth(config);
      this.tasks = new google.tasks('v1', {
        auth: this.auth.client
      });
      this.gmail = new google.gmail('v1', {
        auth: this.auth.client
      });
      this.states.add('Authenticating');
      this.states.on('Syncing.enter', (function(_this) {
        return function() {
          var promise;
          console.log('Syncing.enter');
          promise = _this.Syncing_enter();
          return promise["catch"](promise_exception);
        };
      })(this));
      this.states.on('Syncing.enter', this.Synced_enter);
      this.auth.pipeForward('Ready', this.states, 'Authenticated');
    }

    Sync.prototype.Synced_enter = function() {
      return setTimeout(this.addLater('Syncing'), 5000);
    };

    Sync.prototype.Syncing_enter = coroutine(function*() {
      var list, name, prefetch_labels, query, tasks, tasks_in_threads, threads, value, _ref1;
      this.task_lists = (yield this.getTaskLists(this.task_lists.etag));
      prefetch_labels = this.prefetchLabels();
      _ref1 = this.config.tasks.queries;
      for (name in _ref1) {
        query = _ref1[name];
        if (name === 'labels_defaults') {
          continue;
        }
        console.log("Parsing query '" + name + "'");
        list = null;
        value = (yield Promise.all([
          this.getThreads(query.query), coroutine((function(_this) {
            return function*() {
              list = (yield _this.getListForQuery(name, query));
              return _this.getTasks(list.id);
            };
          })(this))(), prefetch_labels
        ]));
        threads = value[0].threads || [];
        tasks = value[1].items || [];
        console.log("Found " + threads.length + " threads");
        console.log("Found " + tasks.length + " tasks");
        tasks_in_threads = [];
        (yield Promise.all(threads.map(coroutine((function(_this) {
          return function*(thread) {
            var task;
            task = (yield _this.getTaskForThread(thread, tasks, list.id));
            return tasks_in_threads.push(task.id);
          };
        })(this)))));
        (yield Promise.all([this.createThreadFromTasks(tasks, list.id, threads, query), this.markTasksAsCompleted(tasks, list.id, tasks_in_threads)]));
        (yield this.req(this.tasks.tasks.clear, {
          tasklist: list.id
        }));
      }
      return this.states.add('Synced');
    });

    Sync.prototype.prefetchLabels = coroutine(function*() {
      var res;
      res = (yield this.req(this.gmail.users.labels.list, {
        userId: 'me'
      }));
      return this.labels = res[0].labels;
    });

    Sync.prototype.req = function(method, params) {
      console.log('REQUEST');
      console.dir(params);
      if (params == null) {
        params = {};
      }
      params.auth = this.auth.client;
      return (promisify(method))(params);
    };

    Sync.prototype.syncTaskName = coroutine(function*(task, thread) {
      return (yield true);
    });

    Sync.prototype.createTaskList = coroutine(function*(name) {
      var res;
      res = (yield this.req(this.tasks.tasklists.insert, {
        resource: {
          title: name
        }
      }));
      return type(res[1].body, ITaskList, 'ITaskList');
    });

    Sync.prototype.getTaskLists = coroutine(function*(last_etag) {
      var res;
      res = (yield this.req(this.tasks.tasklists.list));
      return type(res[0].items, ITaskLists, 'ITaskLists');
    });

    Sync.prototype.findTaskForThread = function(tasks, thread) {
      var task;
      type(tasks, [ITask], '[ITask]');
      type(thread, IThread, 'IThread');
      task = tasks.find(function(item) {
        var _ref1;
        return (_ref1 = item.notes) != null ? _ref1.match("email:" + thread.id) : void 0;
      });
      return type(task, typedef.Optional(ITask), '?ITask');
    };

    Sync.prototype.createTaskFromThread = coroutine(function*(thread, list_id) {
      var res, title;
      type(list_id, String);
      type(thread, IThread, 'IThread');
      title = this.getTaskTitleFromThread(thread);
      res = (yield this.req(this.tasks.tasks.insert, {
        tasklist: list_id,
        resource: {
          title: title,
          notes: "email:" + thread.id
        }
      }));
      console.log("Task added '" + title + "'");
      return type(res[0], ITask, 'ITask');
    });

    Sync.prototype.createThreadFromTasks = coroutine(function*(tasks, list_id, threads, query) {
      var k, labels, labels_ids, subject, task, thread, _i, _len, _ref1, _ref2, _ref3, _results;
      _ref1 = tasks || [];
      _results = [];
      for (k = _i = 0, _len = _ref1.length; _i < _len; k = ++_i) {
        task = _ref1[k];
        if (!task.title || task.status === 'completed' || ((_ref2 = task.notes) != null ? _ref2.match(/\bemail:\w+\b/) : void 0)) {
          continue;
        }
        labels = ['INBOX'].concat(query['labels_new_task'] || [], ((_ref3 = this.config.tasks.queries.labels_defaults) != null ? _ref3['new_task'] : void 0) || []);
        subject = task.title;
        console.log("Creating email '" + subject + "' (" + (labels.join(', ')) + ")");
        thread = (yield this.req(this.gmail.users.messages.insert, {
          userId: 'me',
          resource: {
            raw: this.createEmail(subject)
          }
        }));
        labels_ids = labels.map((function(_this) {
          return function(name) {
            var label;
            label = _this.labels.find(function(label) {
              return label.name === name;
            });
            return label.id;
          };
        })(this));
        (yield this.req(this.gmail.users.messages.modify, {
          id: thread[0].id,
          userId: 'me',
          resource: {
            addLabelIds: labels_ids
          }
        }));
        if (task.notes == null) {
          task.notes = "";
        }
        task.notes = "" + task.notes + "\nemail:" + thread[0].id;
        _results.push((yield this.req(this.tasks.tasks.patch, {
          tasklist: list_id,
          task: task.id,
          userId: 'me',
          resource: {
            notes: task.notes
          }
        })));
      }
      return _results;
    });

    Sync.prototype.createEmail = function(subject) {
      var email;
      type(subject, String);
      email = ["From: " + this.config.gmail_username + " <" + this.config.gmail_username + ">s", "To: " + this.config.gmail_username, "Content-type: text/html;charset=utf-8", "MIME-Version: 1.0", "Subject: " + subject].join("\r\n");
      return new Buffer(email).toString('base64').replace(/\+/g, '-').replace(/\//g, '_');
    };

    Sync.prototype.getTasks = coroutine(function*(list_id) {
      var res;
      type(list_id, String);
      res = (yield this.req(this.tasks.tasks.list, {
        updatedMin: this,
        tasklist: list_id,
        fields: "etag,items(id,title,notes)",
        maxResults: 1000,
        showCompleted: false
      }));
      return type(res[0], ITasks, 'ITasks');
    });

    Sync.prototype.getTaskForThread = coroutine(function*(thread, tasks, list_id) {
      var task;
      type(thread, IThread, 'IThread');
      type(tasks, [ITask], '[ITask]');
      type(list_id, String);
      task = this.findTaskForThread(tasks, thread);
      if (!task) {
        task = (yield this.createTaskFromThread(thread, list_id));
      }
      return type(task, ITask, 'ITask');
    });

    Sync.prototype.getTaskTitleFromThread = function(thread) {
      var extracted, title;
      title = thread.messages[0].payload.headers[0].value;
      extracted = this.extractLabelsFromThreadName(thread);
      if (this.config.def_title === 1) {
        return "" + (extracted[1].join(' ')) + " " + extracted[0];
      } else {
        return "" + extracted[0] + " " + (extracted[1].join(' '));
      }
    };


    /*
    	@name string
    	@return [ string, Array<Label> ]
     */

    Sync.prototype.extractLabelsFromThreadName = function(thread) {
      var label, labels, name, prefix, r, symbol, _i, _len, _ref1;
      name = thread.messages[0].payload.headers[0].value;
      labels = [];
      _ref1 = this.config.auto_labels;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        r = _ref1[_i];
        symbol = r.symbol;
        label = r.label;
        prefix = r.prefix;
        name = name.replace("(\b|^)" + symbol + "(\w+)", '', function(label) {
          return labels.push(label);
        });
      }
      return type([name, labels], typedef.Vector([String, [String]]));
    };

    Sync.prototype.getThreads = coroutine(function*(query) {
      var list, res, threads;
      type(query, String);
      res = (yield this.req(this.gmail.users.threads.list, {
        q: query,
        userId: "me"
      }));
      list = res[0];
      if (list.threads == null) {
        list.threads = [];
      }
      threads = (yield Promise.all(list.threads.map((function(_this) {
        return function(item) {
          return _this.req(_this.gmail.users.threads.get, {
            id: item.id,
            userId: 'me',
            metadataHeaders: 'SUBJECT',
            format: 'metadata',
            fields: 'id,messages(id,labelIds,payload(headers))'
          });
        };
      })(this))));
      list.threads = threads.map(function(item) {
        return item[0];
      });
      return type(list, IThreads, 'IThreads');
    });

    Sync.prototype.markTasksAsCompleted = coroutine(function*(tasks, list_id, exclude) {
      var k, task, _i, _len, _ref1, _results;
      type(tasks, [ITask], '[ITask]');
      type(list_id, String);
      if (exclude == null) {
        exclude = [];
      }
      _ref1 = tasks || [];
      _results = [];
      for (k = _i = 0, _len = _ref1.length; _i < _len; k = ++_i) {
        task = _ref1[k];
        if ((exclude.contains(task.id)) || task.status === 'completed') {
          continue;
        }
        if (/^email:/.test(task.notes)) {
          (yield this.req(this.tasks.tasks.patch, {
            tasklist: list_id,
            task: task.id,
            resource: {
              status: 'completed'
            }
          }));
          _results.push(console.log("Task completed by email - '" + task.title + "'"));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    });

    Sync.prototype.getListForQuery = coroutine(function*(name, data) {
      var list, r, _i, _len, _ref1;
      type(name, String);
      type(data, IQuery, 'IQuery');
      list = null;
      this.def_title = data.labels_in_title || this.config.labels_in_title;
      _ref1 = this.task_lists;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        r = _ref1[_i];
        if (name === r.title) {
          list = r;
          break;
        }
      }
      if (!list) {
        list = (yield this.createTaskList(name));
        console.log("Creating tasklist '" + name + "'");
      }
      return list;
    });

    return Sync;

  })();

  module.exports = {
    Sync: Sync,
    States: States
  };

}).call(this);
